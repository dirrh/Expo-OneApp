import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { createCanvas, loadImage } from "canvas";
import { generateIOSCompactPins } from "./generate-ios-compact-pins";
import { generateIOSLabeledPins } from "./generate-ios-labeled-pins";
import { normalizeIOSFullMarkers } from "./normalize-ios-full-markers";
import { normalizeIOSClusterMarkers } from "./normalize-ios-cluster-markers";
import { normalizeIOSStackedMarkers } from "./normalize-ios-stacked-markers";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, "..");

const SCALE_FACTOR = 0.375;
const SOURCE_DIR = path.join(ROOT_DIR, "images/icons");
const TARGET_DIR = path.join(SOURCE_DIR, "ios-scaled");
const GENERATED_MAP_FILE = path.join(ROOT_DIR, "lib/maps/generatedIOSScaledImageMap.ts");

const IMAGE_EXTENSIONS = new Set([".png", ".jpg", ".jpeg", ".webp"]);
const INCLUDE_DIRECTORIES = ["cluster", "cluster_orange", "stacked", "full-markers"] as const;
const INCLUDE_FILES = [
  "fitness/fitness_without_review.png",
  "gastro/gastro_without_rating.png",
  "relax/relax_without_rating.png",
  "beauty/beauty_without_rating.png",
  "multi/multi.png",
] as const;

const ensureDirectory = (targetPath: string) => {
  fs.mkdirSync(targetPath, { recursive: true });
};

const normalizeToPosix = (value: string) => value.replace(/\\/g, "/");

const collectFilesFromDirectory = (relativeDirectory: string): string[] => {
  const absoluteDirectory = path.join(SOURCE_DIR, relativeDirectory);
  if (!fs.existsSync(absoluteDirectory)) {
    return [];
  }
  const entries = fs.readdirSync(absoluteDirectory, { withFileTypes: true });
  const files: string[] = [];
  entries.forEach((entry) => {
    if (!entry.isFile()) {
      return;
    }
    const extension = path.extname(entry.name).toLowerCase();
    if (!IMAGE_EXTENSIONS.has(extension)) {
      return;
    }
    files.push(path.join(absoluteDirectory, entry.name));
  });
  return files;
};

const collectSourceFiles = () => {
  const files = new Set<string>();
  INCLUDE_DIRECTORIES.forEach((directory) => {
    collectFilesFromDirectory(directory).forEach((absolutePath) => files.add(absolutePath));
  });
  INCLUDE_FILES.forEach((relativePath) => {
    const absolutePath = path.join(SOURCE_DIR, relativePath);
    if (fs.existsSync(absolutePath)) {
      files.add(absolutePath);
    }
  });
  return Array.from(files);
};

const scaleAsset = async (sourcePath: string, targetPath: string) => {
  const image = await loadImage(sourcePath);
  const width = Math.max(1, Math.round(image.width * SCALE_FACTOR));
  const height = Math.max(1, Math.round(image.height * SCALE_FACTOR));
  const canvas = createCanvas(width, height);
  const context = canvas.getContext("2d");
  context.clearRect(0, 0, width, height);
  context.drawImage(image, 0, 0, width, height);
  ensureDirectory(path.dirname(targetPath));
  fs.writeFileSync(targetPath, canvas.toBuffer("image/png"));
};

const writeGeneratedMap = (sourcePaths: string[]) => {
  const sortedSourcePaths = [...sourcePaths].sort((left, right) =>
    left.localeCompare(right)
  );
  const entries = sortedSourcePaths.map((absolutePath) => {
    const sourceRelative = normalizeToPosix(path.relative(ROOT_DIR, absolutePath));
    const targetRelative = normalizeToPosix(
      path.relative(
        ROOT_DIR,
        path.join(TARGET_DIR, path.relative(SOURCE_DIR, absolutePath))
      )
    );
    const sourceRequirePath = `../../${sourceRelative}`;
    const targetRequirePath = `../../${targetRelative}`;
    return `  [require("${sourceRequirePath}")]: require("${targetRequirePath}"),`;
  });

  const output = `/* eslint-disable */
// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/build-ios-scaled-map-assets.ts

export const IOS_SCALED_ASSET_SCALE_FACTOR = ${SCALE_FACTOR};

export const IOS_SCALED_IMAGE_BY_SOURCE: Record<number, number> = {
${entries.join("\n")}
};
`;

  ensureDirectory(path.dirname(GENERATED_MAP_FILE));
  fs.writeFileSync(GENERATED_MAP_FILE, output, "utf8");
};

const main = async () => {
  const sourcePaths = collectSourceFiles();
  if (sourcePaths.length === 0) {
    throw new Error("No source assets selected for iOS scaled map assets.");
  }
  for (const sourcePath of sourcePaths) {
    const relativePath = path.relative(SOURCE_DIR, sourcePath);
    const targetPath = path.join(TARGET_DIR, relativePath);
    await scaleAsset(sourcePath, targetPath);
  }
  writeGeneratedMap(sourcePaths);
  await normalizeIOSFullMarkers();
  await normalizeIOSStackedMarkers();
  await normalizeIOSClusterMarkers();
  await generateIOSCompactPins();
  await generateIOSLabeledPins();
  console.log(
    `[build-ios-scaled-map-assets] done, scaled=${sourcePaths.length}, map=${path.relative(
      ROOT_DIR,
      GENERATED_MAP_FILE
    )}, compact-and-labeled-pins=generated`
  );
};

void main();
