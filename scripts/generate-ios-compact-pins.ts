import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { createCanvas, loadImage } from "canvas";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, "..");

// Locked uniform iOS full-sprite canvas – must match all other ios-scaled images (+25%)
const CANVAS_WIDTH = 402;
const CANVAS_HEIGHT = 172;
// Pin icon dimensions – same as cluster/stacked normalized scripts
const PIN_ICON_WIDTH = 104;
const PIN_ICON_HEIGHT = 141;
const PIN_OFFSET_X = Math.round((CANVAS_WIDTH - PIN_ICON_WIDTH) / 2);
const PIN_OFFSET_Y = 0;

const GENERATED_FILE = path.join(ROOT_DIR, "lib/maps/generatedIOSCompactPins.ts");
const TARGET_DIR = path.join(ROOT_DIR, "images/icons/ios-scaled/compact-pins");

// Map from category name → source badged icon directory + base filename
const CATEGORIES = [
  { category: "Beauty",  dir: "beauty",  file: "beauty_rating_4.0.png" },
  { category: "Fitness", dir: "fitness", file: "fitness_rating_4.0.png" },
  { category: "Gastro",  dir: "gastro",  file: "gastro_rating_4.0.png" },
  { category: "Relax",   dir: "relax",   file: "relax_rating_4.0.png" },
  // Multi uses Gastro as representative icon
  { category: "Multi",   dir: "gastro",  file: "gastro_rating_4.0.png" },
] as const;

const normalizeToPosix = (value: string) => value.replace(/\\/g, "/");

export const generateIOSCompactPins = async () => {
  fs.mkdirSync(TARGET_DIR, { recursive: true });

  const entries: Array<{ category: string; targetRelative: string }> = [];

  for (const { category, dir, file } of CATEGORIES) {
    const sourcePath = path.join(ROOT_DIR, "images/icons/badged", dir, file);
    if (!fs.existsSync(sourcePath)) {
      console.warn(`[generate-ios-compact-pins] missing source: ${sourcePath}`);
      continue;
    }

    const targetFileName = `${category.toLowerCase()}.png`;
    const targetPath = path.join(TARGET_DIR, targetFileName);

    const sourceImage = await loadImage(sourcePath);
    const canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    ctx.drawImage(sourceImage, PIN_OFFSET_X, PIN_OFFSET_Y, PIN_ICON_WIDTH, PIN_ICON_HEIGHT);

    fs.writeFileSync(targetPath, canvas.toBuffer("image/png"));

    const targetRelative = normalizeToPosix(path.relative(ROOT_DIR, targetPath));
    entries.push({ category, targetRelative });
    console.log(`[generate-ios-compact-pins] wrote ${targetRelative}`);
  }

  // Anchor: pin tip at ~95% of the 104×141 drawn region → y ≈ 134 on 402×172 canvas
  // → anchor y = 134/172 ≈ 0.779  (matches IOS_SCALED_CLUSTER_ANCHOR)
  const entryLines = entries.map(
    ({ category, targetRelative }) =>
      `  ${category}: require("../../${targetRelative}"),`
  );

  const output = [
    "/* eslint-disable */",
    "// AUTO-GENERATED FILE. DO NOT EDIT.",
    "// Generated by scripts/generate-ios-compact-pins.ts",
    "// Text-free compact pin sprites (104×141 badged pin on 402×172 canvas, no category label).",
    "",
    `export const IOS_COMPACT_PIN_BY_CATEGORY: Partial<Record<string, number>> = {`,
    entryLines.join("\n"),
    `};`,
    "",
    "// Anchor for compact pin sprites – pin tip at 95% of the 104×141 draw area,",
    "// offset to (149, 134) on the 402×172 canvas → anchor ≈ (0.492, 0.779).",
    "export const IOS_COMPACT_PIN_ANCHOR = { x: 0.492, y: 0.779 } as const;",
    "",
  ].join("\n");

  fs.writeFileSync(GENERATED_FILE, output, "utf8");
  console.log(
    `[generate-ios-compact-pins] done, canvas=${CANVAS_WIDTH}x${CANVAS_HEIGHT}, wrote ${entries.length} compact pins → ${GENERATED_FILE}`
  );
};

const isDirectRun =
  typeof process.argv[1] === "string" &&
  path.resolve(process.argv[1]) === __filename;

if (isDirectRun) {
  void generateIOSCompactPins();
}
